package testdata

import (
	"database/sql"
	"fmt"
	"html/template"
	"io/ioutil"
	"net/http"
	"os"
	"path/filepath"
)

// Path Traversal vulnerable handler - file operations with user input
func (h *PathTraversalHandler) ReadFileHandler(w http.ResponseWriter, r *http.Request) {
	// Vulnerable: user input used directly in file operation
	filename := r.FormValue("file")
	
	// Direct file read without path validation
	data, err := ioutil.ReadFile(filename)
	if err != nil {
		http.Error(w, "File not found", http.StatusNotFound)
		return
	}
	
	fmt.Fprintf(w, "File content: %s", data)
}

// Path Traversal vulnerable handler - file open with user input
func (h *Handler) OpenFileHandler(w http.ResponseWriter, r *http.Request) {
	// Vulnerable: user input used directly in file operation
	filepath := r.FormValue("path")
	
	// Direct file open without path validation
	file, err := os.Open(filepath)
	if err != nil {
		http.Error(w, "File not found", http.StatusNotFound)
		return
	}
	defer file.Close()
	
	fmt.Fprintf(w, "File opened: %s", filepath)
}

// Path Traversal vulnerable handler - directory operations
func (h *Handler) ListDirectoryHandler(w http.ResponseWriter, r *http.Request) {
	// Vulnerable: user input used directly in directory operation
	dirPath := r.FormValue("directory")
	
	// Direct directory read without path validation
	_, err := ioutil.ReadDir(dirPath)
	if err != nil {
		http.Error(w, "Directory not found", http.StatusNotFound)
		return
	}
	
	fmt.Fprintf(w, "Directory listing: %s", dirPath)
}

// Path Traversal vulnerable handler - file creation
func (h *Handler) CreateFileHandler(w http.ResponseWriter, r *http.Request) {
	// Vulnerable: user input used directly in file creation
	filename := r.FormValue("filename")
	content := r.FormValue("content")
	
	// Direct file creation without path validation
	err := ioutil.WriteFile(filename, []byte(content), 0644)
	if err != nil {
		http.Error(w, "Failed to create file", http.StatusInternalServerError)
		return
	}
	
	fmt.Fprintf(w, "File created: %s", filename)
}

// Path Traversal vulnerable handler - file deletion
func (h *Handler) DeleteFileHandler(w http.ResponseWriter, r *http.Request) {
	// Vulnerable: user input used directly in file deletion
	filename := r.FormValue("file")
	
	// Direct file deletion without path validation
	err := os.Remove(filename)
	if err != nil {
		http.Error(w, "Failed to delete file", http.StatusInternalServerError)
		return
	}
	
	fmt.Fprintf(w, "File deleted: %s", filename)
}

// Path Traversal vulnerable handler - template operations
func (h *Handler) LoadTemplateHandler(w http.ResponseWriter, r *http.Request) {
	// Vulnerable: user input used directly in template loading
	templatePath := r.FormValue("template")
	
	// Direct template loading without path validation
	tmpl, err := template.ParseFiles(templatePath)
	if err != nil {
		http.Error(w, "Template not found", http.StatusNotFound)
		return
	}
	
	tmpl.Execute(w, nil)
}

// Path Traversal vulnerable handler - file copy
func (h *Handler) CopyFileHandler(w http.ResponseWriter, r *http.Request) {
	// Vulnerable: user input used directly in file copy
	sourcePath := r.FormValue("source")
	destPath := r.FormValue("destination")
	
	// Direct file copy without path validation
	sourceFile, err := os.Open(sourcePath)
	if err != nil {
		http.Error(w, "Source file not found", http.StatusNotFound)
		return
	}
	defer sourceFile.Close()
	
	destFile, err := os.Create(destPath)
	if err != nil {
		http.Error(w, "Failed to create destination file", http.StatusInternalServerError)
		return
	}
	defer destFile.Close()
	
	fmt.Fprintf(w, "File copied from %s to %s", sourcePath, destPath)
}

// Path Traversal vulnerable handler - file move
func (h *Handler) MoveFileHandler(w http.ResponseWriter, r *http.Request) {
	// Vulnerable: user input used directly in file move
	oldPath := r.FormValue("old_path")
	newPath := r.FormValue("new_path")
	
	// Direct file move without path validation
	err := os.Rename(oldPath, newPath)
	if err != nil {
		http.Error(w, "Failed to move file", http.StatusInternalServerError)
		return
	}
	
	fmt.Fprintf(w, "File moved from %s to %s", oldPath, newPath)
}

// Path Traversal vulnerable handler - file stat
func (h *Handler) GetFileInfoHandler(w http.ResponseWriter, r *http.Request) {
	// Vulnerable: user input used directly in file stat
	filepath := r.FormValue("file")
	
	// Direct file stat without path validation
	info, err := os.Stat(filepath)
	if err != nil {
		http.Error(w, "File not found", http.StatusNotFound)
		return
	}
	
	fmt.Fprintf(w, "File info: %s", info.Name())
}

// Path Traversal vulnerable handler - directory creation
func (h *Handler) CreateDirectoryHandler(w http.ResponseWriter, r *http.Request) {
	// Vulnerable: user input used directly in directory creation
	dirPath := r.FormValue("directory")
	
	// Direct directory creation without path validation
	err := os.MkdirAll(dirPath, 0755)
	if err != nil {
		http.Error(w, "Failed to create directory", http.StatusInternalServerError)
		return
	}
	
	fmt.Fprintf(w, "Directory created: %s", dirPath)
}

// Path Traversal vulnerable handler - filepath operations
func (h *Handler) JoinPathHandler(w http.ResponseWriter, r *http.Request) {
	// Vulnerable: user input used directly in path joining
	basePath := r.FormValue("base")
	subPath := r.FormValue("sub")
	
	// Direct path joining without validation
	fullPath := filepath.Join(basePath, subPath)
	
	fmt.Fprintf(w, "Joined path: %s", fullPath)
}

// Path Traversal vulnerable handler - file existence check
func (h *Handler) CheckFileExistsHandler(w http.ResponseWriter, r *http.Request) {
	// Vulnerable: user input used directly in file existence check
	filepath := r.FormValue("file")
	
	// Direct file existence check without path validation
	_, err := os.Stat(filepath)
	if os.IsNotExist(err) {
		fmt.Fprintf(w, "File does not exist: %s", filepath)
		return
	}
	
	fmt.Fprintf(w, "File exists: %s", filepath)
}

// Path Traversal vulnerable handler - include operations
func (h *Handler) IncludeFileHandler(w http.ResponseWriter, r *http.Request) {
	// Vulnerable: user input used directly in include operation
	includePath := r.FormValue("include")
	
	// Direct include without path validation
	data, err := ioutil.ReadFile(includePath)
	if err != nil {
		http.Error(w, "Include file not found", http.StatusNotFound)
		return
	}
	
	fmt.Fprintf(w, "Included content: %s", data)
}

// PathTraversalHandler struct for HTTP handlers
type PathTraversalHandler struct {
	db *sql.DB
}

var pathTraversalDB *sql.DB 