package testdata

import (
	"fmt"
	"net"
	"net/http"
	"net/url"
	"os"
	"strings"
)

// BAD: HTTP request with user input (SSRF)
func fetchUserData(userInput string) error {
	// VULNERABILITY: User input used directly in HTTP request
	resp, err := http.Get(userInput)
	if err != nil {
		return err
	}
	defer resp.Body.Close()
	
	fmt.Printf("Response status: %s\n", resp.Status)
	return nil
}

// BAD: DNS lookup with user input (SSRF)
func resolveHostname(userInput string) error {
	// VULNERABILITY: User input used in DNS lookup
	ips, err := net.LookupHost(userInput)
	if err != nil {
		return err
	}
	
	fmt.Printf("Resolved IPs: %v\n", ips)
	return nil
}

// BAD: File operation with user input (SSRF)
func readUserFile(userInput string) error {
	// VULNERABILITY: User input used in file operation
	file, err := os.Open(userInput)
	if err != nil {
		return err
	}
	defer file.Close()
	
	data := make([]byte, 1024)
	_, err = file.Read(data)
	return err
}

// BAD: URL construction with user input
func processURL(userInput string) error {
	// VULNERABILITY: User input used to construct URL
	baseURL := "https://api.example.com/data"
	fullURL := baseURL + "?param=" + userInput
	
	resp, err := http.Get(fullURL)
	if err != nil {
		return err
	}
	defer resp.Body.Close()
	
	fmt.Printf("Response: %s\n", resp.Status)
	return nil
}

// BAD: HTTP client with user-controlled URL
func makeRequest(userInput string) error {
	// VULNERABILITY: User input used in HTTP client
	client := &http.Client{}
	req, err := http.NewRequest("GET", userInput, nil)
	if err != nil {
		return err
	}
	
	resp, err := client.Do(req)
	if err != nil {
		return err
	}
	defer resp.Body.Close()
	
	fmt.Printf("Response: %s\n", resp.Status)
	return nil
}

// GOOD: Validated URL before request
func secureFetchUserData(userInput string) error {
	// Safe: Validate URL before making request
	parsedURL, err := url.Parse(userInput)
	if err != nil {
		return fmt.Errorf("invalid URL: %w", err)
	}
	
	// Whitelist allowed domains
	allowedDomains := []string{"api.example.com", "trusted.example.com"}
	allowed := false
	for _, domain := range allowedDomains {
		if parsedURL.Hostname() == domain {
			allowed = true
			break
		}
	}
	
	if !allowed {
		return fmt.Errorf("domain not allowed: %s", parsedURL.Hostname())
	}
	
	// Only allow HTTP/HTTPS schemes
	if parsedURL.Scheme != "http" && parsedURL.Scheme != "https" {
		return fmt.Errorf("unsupported scheme: %s", parsedURL.Scheme)
	}
	
	resp, err := http.Get(parsedURL.String())
	if err != nil {
		return err
	}
	defer resp.Body.Close()
	
	fmt.Printf("Response status: %s\n", resp.Status)
	return nil
}

// GOOD: Whitelisted hostname resolution
func secureResolveHostname(userInput string) error {
	// Safe: Validate hostname before DNS lookup
	allowedHostnames := []string{"api.example.com", "trusted.example.com"}
	allowed := false
	for _, hostname := range allowedHostnames {
		if userInput == hostname {
			allowed = true
			break
		}
	}
	
	if !allowed {
		return fmt.Errorf("hostname not allowed: %s", userInput)
	}
	
	ips, err := net.LookupHost(userInput)
	if err != nil {
		return err
	}
	
	fmt.Printf("Resolved IPs: %v\n", ips)
	return nil
}

// GOOD: Safe file operation with path validation
func secureReadFile(userInput string) error {
	// Safe: Validate file path before operation
	if !isValidFilePath(userInput) {
		return fmt.Errorf("invalid file path: %s", userInput)
	}
	
	// Ensure path is within allowed directory
	allowedDir := "/var/www/data/"
	if !strings.HasPrefix(userInput, allowedDir) {
		return fmt.Errorf("file path outside allowed directory")
	}
	
	file, err := os.Open(userInput)
	if err != nil {
		return err
	}
	defer file.Close()
	
	data := make([]byte, 1024)
	_, err = file.Read(data)
	return err
}

// Helper function for safe file path validation
func isValidFilePath(path string) bool {
	// Implementation would validate file path
	return !strings.Contains(path, "..") && !strings.Contains(path, "~")
} 