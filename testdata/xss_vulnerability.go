package main

import (
	"fmt"
	"html/template"
	"net/http"
)

// BAD: XSS vulnerability with direct output
func handleUserInput(w http.ResponseWriter, r *http.Request) {
	userInput := r.URL.Query().Get("name")
	
	// VULNERABILITY: User input directly output to HTML
	html := fmt.Sprintf("<h1>Hello, %s!</h1>", userInput)
	fmt.Fprintf(w, html)
}

// BAD: XSS with template but unsafe content
func renderUserProfile(w http.ResponseWriter, r *http.Request) {
	userInput := r.URL.Query().Get("bio")
	
	// VULNERABILITY: User input used in template without escaping
	tmpl := template.Must(template.New("profile").Parse(`
		<html>
			<body>
				<h1>User Profile</h1>
				<div>{{.}}</div>
			</body>
		</html>
	`))
	
	tmpl.Execute(w, userInput)
}

// BAD: XSS with JavaScript injection
func handleSearch(w http.ResponseWriter, r *http.Request) {
	searchTerm := r.URL.Query().Get("q")
	
	// VULNERABILITY: User input used in JavaScript
	js := fmt.Sprintf("<script>alert('Searching for: %s');</script>", searchTerm)
	fmt.Fprintf(w, js)
}

// BAD: XSS with attribute injection
func renderLink(w http.ResponseWriter, r *http.Request) {
	url := r.URL.Query().Get("url")
	
	// VULNERABILITY: User input used in HTML attribute
	link := fmt.Sprintf("<a href='%s'>Click here</a>", url)
	fmt.Fprintf(w, link)
}

// GOOD: Safe XSS prevention
func safeHandleUserInput(w http.ResponseWriter, r *http.Request) {
	userInput := r.URL.Query().Get("name")
	
	// Safe: Use html/template for automatic escaping
	tmpl := template.Must(template.New("safe").Parse(`
		<html>
			<body>
				<h1>Hello, {{.}}!</h1>
			</body>
		</html>
	`))
	
	tmpl.Execute(w, userInput)
}

// GOOD: Safe JavaScript handling
func safeSearch(w http.ResponseWriter, r *http.Request) {
	searchTerm := r.URL.Query().Get("q")
	
	// Safe: Use template with proper escaping
	tmpl := template.Must(template.New("search").Parse(`
		<script>
			alert('Searching for: {{.}}');
		</script>
	`))
	
	tmpl.Execute(w, searchTerm)
} 